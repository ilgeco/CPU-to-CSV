

use nom::{
    bytes::complete::tag,
    character::complete::{digit0, multispace0, alphanumeric1, space0},
    number::complete::double,
    sequence::{pair, preceded},
    IResult,
};

fn get_cpu(content: &str) -> IResult<&str, (&str, &str)> {
    preceded(multispace0, pair(tag("cpu"), digit0))(content)
}

fn get_number(content: &str) -> IResult<&str, f64> {
    preceded(multispace0, double)(content)
}

fn get_token(content: &str) -> IResult<&str, &str> {
    preceded(space0, alphanumeric1)(content)
}

pub fn number_of_spaced_elements(mut content: &str) -> usize {
    let mut counter = 0;
    while let Ok((left, _)) = get_token(content) {
        content=left;
        counter+=1;
    }
    counter
    
}

pub fn parse_cpu_file_line<'a, 'b>(
    content: &'a str,
    storage: &'b mut Vec<f64>,
    n: usize,
) -> IResult<&'a str, (&'a str, &'b mut Vec<f64>)> {
    let (mut content, (_, cpu_number)) = get_cpu(content)?;

    for _ in 0..n {
        match get_number(content) {
            Ok((input_left, cpu_time)) => {
                storage.push(cpu_time);
                content = input_left
            }
            Err(nom::Err::Error(x)) => {
                return Err(nom::Err::Error(x));
            }
            _ => panic!("Parsing error not handled"),
        }
    }

    return Ok((content, (cpu_number, storage)));
}

#[cfg(test)]
mod test_parser {

    use super::*;

    fn compare(lft: &[f64], rgt: &Vec<f64>) -> bool {
        if lft.len() != rgt.len() {
            return false;
        }
        for (l, r) in lft.iter().zip(rgt) {
            if l != r {
                return false;
            }
        }
        return true;
    }

    #[test]
    fn simple_count_test() {
        let input = "one two three four";
        assert_eq!(number_of_spaced_elements(&input) ,4);
    }

    #[test]
    fn simple_error_test() {
        let input = r"
        
        intr 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";
        let mut buff = Vec::new();
        let err = parse_cpu_file_line(&input, &mut buff, 3);

        let error_out = r"intr 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";

        let orig = err.unwrap_err();
        let matcher = nom::Err::Error(nom::error::Error::new(
            error_out,
            nom::error::ErrorKind::Tag,
        ));

        assert_eq!(orig, matcher);
    }

    #[test]
    fn simple_float_error_test() {
        let input = r"
        
        cpu2 asa 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";
        let mut  buff = Vec::new();
        let err = parse_cpu_file_line(&input, &mut buff, 3);

        let error_out = r"asa 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";

        let orig = err.unwrap_err();
        let matcher = nom::Err::Error(nom::error::Error::new(
            error_out,
            nom::error::ErrorKind::Float,
        ));

        assert_eq!(orig, matcher);
    }

    #[test]
    fn simple_parse_test() {
        let input = r"cpu  376656.0 775.0 125918.0 12768162.0 40026.0 0.0 3856.0 0.0 0.0 0.0
        cpu0 54257.0 168.0 18703.0 1566935.0 19882.0 0.0 963.0 0.0 0.0 0.0
        cpu1 44305.0 244.0 14644.0 1591812.0 3965.0 0.0 968.0 0.0 0.0 0.0
        intr 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";

        let mut buff = Vec::new();
        let (left_input, (cpu_number, buff)) = parse_cpu_file_line(&input, &mut buff, 10).unwrap();
        assert_eq!("cpu", format!("cpu{}", cpu_number));
        assert!(compare(
            &[376656.0, 775.0, 125918.0, 12768162.0, 40026.0, 0.0, 3856.0, 0.0, 0.0, 0.0],
            &buff
        ));

        let mut buff = Vec::new();
        let (left_input, (cpu_number, buff)) = parse_cpu_file_line(&left_input, &mut buff, 10).unwrap();
        assert_eq!("cpu0", format!("cpu{}", cpu_number));
        assert!(compare(
            &[54257.0, 168.0, 18703.0, 1566935.0, 19882.0, 0.0, 963.0, 0.0, 0.0, 0.0],
            &buff
        ));

        let mut buff = Vec::new();
        let (left_input, (cpu_number, buff)) = parse_cpu_file_line(&left_input, &mut buff, 10).unwrap();
        assert_eq!("cpu1", format!("cpu{}", cpu_number));
        assert!(compare(
            &[44305.0, 244.0, 14644.0, 1591812.0, 3965.0, 0.0, 968.0, 0.0, 0.0, 0.0],
            &buff
        ));

        let err = parse_cpu_file_line(&left_input, buff, 10);

        let error_out = r"intr 29242286 0 25661 0 0 0 0 0 0 0 47759 0 0 2503862 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 117 127 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 6498 55 0 21 230 1036 586 520 681 476 494 1826808 660 117 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88702 5380 6256 9587 6409 6096 7123 6944 6878 7 3129 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        ";

        let orig = err.unwrap_err();
        let matcher = nom::Err::Error(nom::error::Error::new(
            error_out,
            nom::error::ErrorKind::Tag,
        ));

        assert_eq!(orig, matcher);
    }
}
